/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{$generateHtmlFromNodes as t,$generateNodesFromDOM as e}from"@lexical/html";import{$addNodeStyle as n,$sliceSelectedTextNodeContent as o}from"@lexical/selection";import{objectKlassEquals as r}from"@lexical/utils";import{$isRangeSelection as i,$getSelection as l,$createTabNode as s,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as c,$caretFromPoint as a,$isTextPointCaret as u,$getCaretRange as f,$getChildCaret as d,$getRoot as p,$isTextNode as g,$isElementNode as m,$parseSerializedNode as h,getDOMSelection as x,COPY_COMMAND as w,COMMAND_PRIORITY_CRITICAL as y,isSelectionWithinEditor as T,$getEditor as v,$cloneWithProperties as C}from"lexical";function D(t,...e){const n=new URL("https://lexical.dev/docs/error"),o=new URLSearchParams;o.append("code",t);for(const t of e)o.append("v",t);throw n.search=o.toString(),Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}function N(e,n=l()){return null==n&&D(166),i(n)&&n.isCollapsed()||0===n.getNodes().length?"":t(e,n)}function S(t,e=l()){return null==e&&D(166),i(e)&&e.isCollapsed()||0===e.getNodes().length?null:JSON.stringify(E(t,e))}function R(t,e){const n=t.getData("text/plain")||t.getData("text/uri-list");null!=n&&e.insertRawText(n)}function A(t,n,o){const r=t.getData("application/x-lexical-editor");if(r)try{const t=JSON.parse(r);if(t.namespace===o._config.namespace&&Array.isArray(t.nodes)){return P(o,L(t.nodes),n)}}catch(t){}const c=t.getData("text/html"),a=t.getData("text/plain");if(c&&a!==c)try{const t=(new DOMParser).parseFromString(function(t){if(window.trustedTypes&&window.trustedTypes.createPolicy){return window.trustedTypes.createPolicy("lexical",{createHTML:t=>t}).createHTML(t)}return t}(c),"text/html");return P(o,e(o,t),n)}catch(t){}const u=a||t.getData("text/uri-list");if(null!=u)if(i(n)){const t=u.split(/(\r?\n|\t)/);""===t[t.length-1]&&t.pop();for(let e=0;e<t.length;e++){const n=l();if(i(n)){const o=t[e];"\n"===o||"\r\n"===o?n.insertParagraph():"\t"===o?n.insertNodes([s()]):n.insertText(o)}}}else n.insertRawText(u)}function P(t,e,n){t.dispatchCommand(c,{nodes:e,selection:n})||(n.insertNodes(e),function(t){if(i(t)&&t.isCollapsed()){const e=t.anchor;let n=null;const o=a(e,"previous");if(o)if(u(o))n=o.origin;else{const t=f(o,d(p(),"next").getFlipped());for(const e of t){if(g(e.origin)){n=e.origin;break}if(m(e.origin)&&!e.origin.isInline())break}}if(n&&g(n)){const e=n.getFormat(),o=n.getStyle();t.format===e&&t.style===o||(t.format=e,t.style=o,t.dirty=!0)}}}(n))}function _(t,e,n,r=[]){let i=null===e||n.isSelected(e);const l=m(n)&&n.excludeFromCopy("html");let s=n;if(null!==e){let t=C(n);t=g(t)&&null!==e?o(e,t):t,s=t}const c=m(s)?s.getChildren():[],a=function(t){const e=t.exportJSON(),n=t.constructor;if(e.type!==n.getType()&&D(58,n.name),m(t)){const t=e.children;Array.isArray(t)||D(59,n.name)}return e}(s);if(g(s)){const t=s.__text;t.length>0?a.text=t:i=!1}for(let o=0;o<c.length;o++){const r=c[o],l=_(t,e,r,a.children);!i&&m(n)&&l&&n.extractWithChild(r,e,"clone")&&(i=!0)}if(i&&!l)r.push(a);else if(Array.isArray(a.children))for(let t=0;t<a.children.length;t++){const e=a.children[t];r.push(e)}return i}function E(t,e){const n=[],o=p().getChildren();for(let r=0;r<o.length;r++){_(t,e,o[r],n)}return{namespace:t._config.namespace,nodes:n}}function L(t){const e=[];for(let o=0;o<t.length;o++){const r=t[o],i=h(r);g(i)&&n(i),e.push(i)}return e}let b=null;async function F(t,e,n){if(null!==b)return!1;if(null!==e)return new Promise(((o,r)=>{t.update((()=>{o(M(t,e,n))}))}));const o=t.getRootElement(),i=t._window||window,l=window.document,s=x(i);if(null===o||null===s)return!1;const c=l.createElement("span");c.style.cssText="position: fixed; top: -1000px;",c.append(l.createTextNode("#")),o.append(c);const a=new Range;return a.setStart(c,0),a.setEnd(c,1),s.removeAllRanges(),s.addRange(a),new Promise(((e,o)=>{const i=t.registerCommand(w,(o=>(r(o,ClipboardEvent)&&(i(),null!==b&&(window.clearTimeout(b),b=null),e(M(t,o,n))),!0)),y);b=window.setTimeout((()=>{i(),b=null,e(!1)}),50),l.execCommand("copy"),c.remove()}))}function M(t,e,n){if(void 0===n){const e=x(t._window);if(!e)return!1;const o=e.anchorNode,r=e.focusNode;if(null!==o&&null!==r&&!T(t,o,r))return!1;const i=l();if(null===i)return!1;n=J(i)}e.preventDefault();const o=e.clipboardData;return null!==o&&(k(o,n),!0)}const O=[["text/html",N],["application/x-lexical-editor",S]];function J(t=l()){const e={"text/plain":t?t.getTextContent():""};if(t){const n=v();for(const[o,r]of O){const i=r(n,t);null!==i&&(e[o]=i)}}return e}function k(t,e){for(const n in e){const o=e[n];void 0!==o&&t.setData(n,o)}}export{E as $generateJSONFromSelectedNodes,L as $generateNodesFromSerializedNodes,J as $getClipboardDataFromSelection,N as $getHtmlContent,S as $getLexicalContent,R as $insertDataTransferForPlainText,A as $insertDataTransferForRichText,P as $insertGeneratedNodes,F as copyToClipboard,k as setLexicalClipboardDataTransfer};
