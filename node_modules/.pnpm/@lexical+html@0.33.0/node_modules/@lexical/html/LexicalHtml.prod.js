/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

"use strict";var e=require("@lexical/selection"),t=require("@lexical/utils"),n=require("lexical");function o(l,i,r,s=null){let c=null===s||i.isSelected(s);const d=n.$isElementNode(i)&&i.excludeFromCopy("html");let u=i;if(null!==s){let t=n.$cloneWithProperties(i);t=n.$isTextNode(t)&&null!==s?e.$sliceSelectedTextNodeContent(s,t):t,u=t}const a=n.$isElementNode(u)?u.getChildren():[],f=n.getRegisteredNode(l,u.getType());let m;m=f&&void 0!==f.exportDOM?f.exportDOM(l,u):u.exportDOM(l);const{element:h,after:p}=m;if(!h)return!1;const g=document.createDocumentFragment();for(let e=0;e<a.length;e++){const t=a[e],r=o(l,t,g,s);!c&&n.$isElementNode(i)&&r&&i.extractWithChild(t,s,"html")&&(c=!0)}if(c&&!d){if((t.isHTMLElement(h)||n.isDocumentFragment(h))&&h.append(g),r.append(h),p){const e=p.call(u,h);e&&(n.isDocumentFragment(h)?h.replaceChildren(e):h.replaceWith(e))}}else r.append(g);return c}const l=new Set(["STYLE","SCRIPT"]);function i(e,o,s,c,d=new Map,u){let a=[];if(l.has(e.nodeName))return a;let f=null;const m=function(e,t){const{nodeName:n}=e,o=t._htmlConversions.get(n.toLowerCase());let l=null;if(void 0!==o)for(const t of o){const n=t(e);null!==n&&(null===l||(l.priority||0)<=(n.priority||0))&&(l=n)}return null!==l?l.conversion:null}(e,o),h=m?m(e):null;let p=null;if(null!==h){p=h.after;const t=h.node;if(f=Array.isArray(t)?t[t.length-1]:t,null!==f){for(const[,e]of d)if(f=e(f,u),!f)break;f&&a.push(...Array.isArray(t)?t:[f])}null!=h.forChild&&d.set(e.nodeName,h.forChild)}const g=e.childNodes;let N=[];const $=(null==f||!n.$isRootOrShadowRoot(f))&&(null!=f&&n.$isBlockElementNode(f)||c);for(let e=0;e<g.length;e++)N.push(...i(g[e],o,s,$,new Map(d),f));return null!=p&&(N=p(N)),t.isBlockDomNode(e)&&(N=r(e,N,$?()=>{const e=new n.ArtificialNode__DO_NOT_USE;return s.push(e),e}:n.$createParagraphNode)),null==f?N.length>0?a=a.concat(N):t.isBlockDomNode(e)&&function(e){if(null==e.nextSibling||null==e.previousSibling)return!1;return n.isInlineDomNode(e.nextSibling)&&n.isInlineDomNode(e.previousSibling)}(e)&&(a=a.concat(n.$createLineBreakNode())):n.$isElementNode(f)&&f.append(...N),a}function r(e,t,o){const l=e.style.textAlign,i=[];let r=[];for(let e=0;e<t.length;e++){const s=t[e];if(n.$isBlockElementNode(s))l&&!s.getFormat()&&s.setFormat(l),i.push(s);else if(r.push(s),e===t.length-1||e<t.length-1&&n.$isBlockElementNode(t[e+1])){const e=o();e.setFormat(l),e.append(...r),i.push(e),r=[]}}return i}exports.$generateHtmlFromNodes=function(e,t){if("undefined"==typeof document||"undefined"==typeof window&&void 0===global.window)throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");const l=document.createElement("div"),i=n.$getRoot().getChildren();for(let n=0;n<i.length;n++){o(e,i[n],l,t)}return l.innerHTML},exports.$generateNodesFromDOM=function(e,t){const o=t.body?t.body.childNodes:[];let r=[];const s=[];for(let t=0;t<o.length;t++){const n=o[t];if(!l.has(n.nodeName)){const t=i(n,e,s,!1);null!==t&&(r=r.concat(t))}}return function(e){for(const t of e)t.getNextSibling()instanceof n.ArtificialNode__DO_NOT_USE&&t.insertAfter(n.$createLineBreakNode());for(const t of e){const e=t.getChildren();for(const n of e)t.insertBefore(n);t.remove()}}(s),r};
