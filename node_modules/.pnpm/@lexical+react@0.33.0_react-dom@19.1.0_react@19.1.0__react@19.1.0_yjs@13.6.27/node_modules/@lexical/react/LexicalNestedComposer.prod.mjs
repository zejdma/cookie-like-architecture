/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{useCollaborationContext as e}from"@lexical/react/LexicalCollaborationContext";import{LexicalComposerContext as t,createLexicalComposerContext as r}from"@lexical/react/LexicalComposerContext";import{createSharedNodeState as o,getRegisteredNode as n}from"lexical";import{useRef as i,useContext as s,useMemo as a,useEffect as l}from"react";import{jsx as c}from"react/jsx-runtime";function p(e){const t=e.transform();return new Set(t?[t]:[])}const f=()=>{},d=()=>{};function m({initialEditor:m,children:h,initialNodes:u,initialTheme:g,skipCollabChecks:x,skipEditableListener:_}){const v=i(!1),E=s(t);null==E&&function(e,...t){const r=new URL("https://lexical.dev/docs/error"),o=new URLSearchParams;o.append("code",e);for(const e of t)o.append("v",e);throw r.search=o.toString(),Error(`Minified Lexical error #${e}; visit ${r.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}(9);const[k,{getTheme:w}]=E,b=a((()=>{const e=g||w()||void 0,t=r(E,e);void 0!==e&&(m._config.theme=e),m._parentEditor=m._parentEditor||k;const i=m._createEditorArgs,s=i&&i.namespace;if(u){f(),s||(d(),m._config.namespace=k._config.namespace);for(let e of u){let t=null,r=null;if("function"!=typeof e){const o=e;e=o.replace,t=o.with,r=o.withKlass||null}const i=n(m,e.getType());m._nodes.set(e.getType(),{exportDOM:i?i.exportDOM:void 0,klass:e,replace:t,replaceWithKlass:r,sharedNodeState:o(e),transforms:p(e)})}}else if(i&&i.nodes)s||(d(),m._config.namespace=k._config.namespace);else{const e=m._nodes=new Map(k._nodes);s||(m._config.namespace=k._config.namespace);for(const[t,r]of e)m._nodes.set(t,{exportDOM:r.exportDOM,klass:r.klass,replace:r.replace,replaceWithKlass:r.replaceWithKlass,sharedNodeState:o(r.klass),transforms:p(r.klass)})}return[m,t]}),[]),{isCollabActive:C,yjsDocMap:L}=e(),M=x||v.current||L.has(m.getKey());return l((()=>{M&&(v.current=!0)}),[M]),l((()=>{if(!_){const e=e=>m.setEditable(e);return e(k.isEditable()),k.registerEditableListener(e)}}),[m,k,_]),c(t.Provider,{value:b,children:!C||M?h:null})}export{m as LexicalNestedComposer};
